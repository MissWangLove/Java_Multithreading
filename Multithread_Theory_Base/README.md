### 多线程并发:

#### 全景图

- 分工
- 协作
- 互斥

#### 并发编程的源头

- 可见性 : 一个线程对共享变量的修改对另一个线程可见.(多CPU多线程导致的CPU缓存不可见问题 - VisibilityDemo)
- 原子性 : 操作不可分割.(高级语言多条CPU指令分割带来的原子性问题 - AtomicityDemo)
- 有序性 : 程序的顺序执行.(JVM的编译优化 - OrderlyDemo)

volatile - 禁用缓存, 可见 - VolatileDemo

happen-before - 可见, 有序 - HappenBeforeDemo

锁 - 原子性 - atomicity包下   

#### 并发编程注意的问题

- 安全性问题: 数据竞争和竞态条件
- 活跃性问题: 死锁, 活锁和饥饿
- 性能问题: 串行化带来的性能问题

###### 安全性问题

线程安全: 程序能够按照我们期望的执行下去. 也就是说线程安全理论上是不会产生原子性, 可见性和有序性问题的.

什么时候需要注意线程安全? 那就是并发问题产生的原因: 其实就是共享数据且数据会发生变化(多个线程同时读写数据).

数据竞争: 多个线程共享数据, 并且至少有一个线程会写数据.
```

public class Test {
  private long count = 0;
  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      count += 1;
    }
  }
}
```

竞态条件: 程序的执行结果会依赖线程的执行顺序(或者说依赖于某个状态的变量).
```

public class Test {
  private long count = 0;
  synchronized long get(){
    return count；
  }
  synchronized void set(long v){
    count = v;
  } 
  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      // 多个线程执行这行, 结果依赖于线程的执行顺序, 同时, 结果是1, 有先后顺序, 结果是2
      set(get()+1)      
    }
  }
}
// 再比说说转账的判断, 转账金额要小于卡内余额, 如果两个线程同时执行这行, 条件都满足, 一个线程减去转账金额后, 这个时候卡内余额
// 可能就小于转账金额了, 这个时候的条件就发生改变, 不满足, 但是线程2已经开始进行了转账操作, 会出现超额的问题

class Account {
  private int balance;
  // 转账
  void transfer(
      Account target, int amt){
    if (this.balance > amt) {
      this.balance -= amt;
      target.balance += amt;
    }
  } 
}

// 解决这类问题就是要依赖于前面说的互斥, 就是使用锁
```

###### 活跃性问题

 - 死锁: 占有资源等待, 不可抢占, 循环等待(目前所学解决方案是等待唤醒机制)
 - 活锁: 线程无阻塞, 但是执行不下去. 举例子独木桥相互谦让, 同时退, 看到对方推又同时进.(解决方案等待随机事件)
 - 饥饿: 因线程无法访问所需的资源而无法进行下去(结局方案: 保证资源充足(不现实), 平均分配资源(使用公平锁), 防止线程占据锁时间过长(不现实))
 
 ###### 性能问题
 
 性能问题就是有可能会过度的使用锁造成程序串行化, 这样就会大大地影响性能.
 
 解决方案:
 - 无锁机制: 线程本地存储(Thread Local Storage, TLS), 写入时复制(Copy-on-write), 乐观锁等, Java并发包原子类等
 - 减少锁持有的时间: 使用细粒度锁, Java里面的额ConcurrentHashMap就是使用分段锁技术; 读写锁等.
 
 
 #### 管程 - 并发编程的万能钥匙
 
 管程指的是管理共享变成并操作共享变量的过程, 让他们支持并发(这也就意味着管程其实是一系列的动作).
 
 管程的三种模型:
 - Hasen模型
 - Hoare模型
 - MESA模型(Java参考)
 
 ##### MESA模型
 
 并发编程领域的两大问题就是互斥(同一时刻只允许一个线程访问共享变量)和同步(线程之间的通信, 协作).
 
 管程如何解决互斥问题? 这个可以想象一个队列数据结构, 共享变量是一个队列, 操作是入队和出队, 互斥其实就是在入队和出队的操作上加锁
 保证了入队和出队这两个操作互斥, 多个线程要想访问队列, 只能使用提供的入队和出队方法, 这就保持了互斥.
```
monitor X {
    // 共享变量, 队列
    var queue;
    // 入队操作
    func equ();
    // 出队操作
    func deq();
}
 感觉这种其实就是synchronized的互斥实现
```

管程如何解决同步问题呢? 管程解决同步问题其实就是前面说的等待唤醒机制. -  BlockedQueue类

###### wait()

while循环中使用wait, 这是MESA模型特有的.
```
while(条件不满足) {
  wait();
}
```

不同模型的核心区别之一就是当条件满足后, 如何通知相关线程:
- Hasen模型中, notify要求放在代码的最后, 也就是说线程T1执行到最后, 通知T2线程, 这个时候T1也就执行完成了.T2开始执行, 保证同一时刻
只有一个线程执行
- Hoare模型中, 条件满足之后, T1线程立即通知T2线程, T2线程开始运行, T1线程阻塞, T2执行完成之后, T1才继续执行, 多了一步阻塞操作.
- MESA模型中, T1通知T2后, T1会继续执行, T2不会立即执行, 而是从条件变量队列中进入到入口等待队列中(阻塞状态变成可运行状态, 等待系统资源调度), 
好处是notify不用放在代码最后, 也没有多于的阻塞操作, 坏处就是当T2开始执行的时候可能前面满足的条件现在又不满足了, 这就需要用循环方式检验队列了.

###### notify() 和 notifyAll()

一般情况下, 全部使用notifyAll(), 不要轻易使用notify(), 使用notify的三个必要条件:

- 所有的等待线程拥有相同的条件
- 唤醒之后执行的操作都相同
- 只需要唤醒一个线程
 
 
 